DGD 1.0.a0

Differences with LPmud 3.1.2:

Language:

 - No keywords "protected", "public" and "status".
 - Mappings, as in the mappings package that I made for LPmud, with one
   difference: there is no m_delete(), and the normal way to remove an
   index/value pair from a mapping is to set the value to 0.
 - Typechecking is more strict.  As in LPmud 3.1.2, functions are not
   typechecked if they have no declared type, but it is possible to enforce
   typechecking in all objects.
 - call_other() does not require a cast.  If the type is not clear from the
   context, a cast is recommended.
 - Types such as int**, string***** are possible.
 - Initializers are not supported.
 - Indexing out of range is not allowed on arrays and strings.  Negative
   indices can be used to offset from the end of the array/string (-1 last,
   -2 last but one, etc).
 - Indexed string assignments such as foo = "bar"; foo[0] = 'B'; are possible.
 - The zero size array and zero size mapping are not globally shared, and
   comparisions such as array == ({ }) will fail.
 - It is illegal to declare any functions, function prototypes or variables
   before inheriting.
 - Inheritance is completely different.  There are two kinds of inheritance,
   virtual and labeled.
   Virtual inheritance is the default.  If A is inherited by B and C, and D
   inherits A, then the variables of A are in D only once.  It is illegal to
   inherit two different functions with the same name, unless function F1 is
   inherited in the object that defines function F2, or if at least one of
   F1 and F2 is private.  It is illegal to inherit two different variables
   with the same name, unless at least one of them is private.  It is
   illegal to redeclare a non-private variable.  Private functions are
   private in the program that defines them, and cannot be used from inherited
   objects.  Private functions do not mask inherited functions, except in
   the program in which they are defined.  It is illegal to inherit two
   different instances from an object.
   Labeled inheritance uses the syntax inherit label "file"; Functions in
   labeled inherited objects can be accessed with  label::function();
   Variables in labeled inherited objects cannot be accessed from the
   current program at all.  Functions and variables need not be unique
   between labeled inherited objects.  It is possible to inherit the same
   object with labeled inheritance twice; the different instances will not
   share their variables.
 - There is an object that is automatically (virtually) inherited in all other
   objects, called the auto object for short.  The auto object is shared
   even between virtual inherits and labeled inherits.
 - Predefined functions are called kfuns (kernel functions); the kfuns and
   the non-private functions declared in the auto object together are called
   efuns.  Kfuns are assumed to be static functions inherited in the auto
   object, with the added limitation that they cannot be called with
   this_object()->kfun().  All static functions declared in the auto object
   share this limitation.
 - There is no class_specifier inherit "file"; This did not work in LPmud 3.1.2
   anyhow.
 - Function prototypes are always inherited together with the function.
 - Function calls are typechecked if the called function is typechecked.  It
   is illegal to call a non-varargs function with the wrong number of
   arguments from a typechecked function, even if the inherited function is
   not typechecked itself.
 - Kfuns are not treated differently from other inherited functions, so
   destruct(this_object(), this_object()); will not cause a compile-time
   error in an untypechecked function.
 - Inherited functions may be redeclared with a different prototype.  If
   an inherited function is redeclared with a prototype only, and the function
   itself is not declared in the same program, then all calls to the function
   from that program will call an undefined function, which will result in a
   runtime error.
 - If object A declares function F, and B has only a prototype for function
   F, calls to F from B will call function F in A if A and B are inherited
   in the same object.
 - It is illegal to inherit a function and a prototype for the same function
   if the prototypes do not match.
 - A call to an undeclared function from an untypechecked function implicitly
   declares a prototype for the undeclared function that matches anything.
 - this_object()->function(); can be used to call static functions, but not
   private ones.
 - foo->bar(gnu); is merely an alias for call_other(foo, bar, gnu);  It is
   therefore possible to redefine call_other() entirely.
 - lock(expr); will evaluate expr without regard of execution cost, and with
   extra space on the function call stack.  It can only be used by the auto
   object to ensure that execution does not halt inside a critical function.
 - Any kfun can be redefined, just as ordinary inherited functions can.
   catch() and lock() are not considered to be kfuns (they are not true
   functions because catch(foo, bar) does not "call catch with two arguments").

Compiler:

 - The built-in preprocessor conforms to the ANSI standard, except for the
   following:
    - No trigraphs.
    - Successive string constants are not concatenated (use the + operator
      instead).
    - The suffixes U and L are not allowed on integer constants.
    - No floating point constants.
 - There is a standard include file which is included automatically.
 - All #pragma directives are ignored.
 - All integer constants may be in decimal (starting with 1-9), octal (starting
   with 0), hexadecimal (starting with 0x) or a character constant 'x'.  The
   only escaped characters that are translated into something else in
   character constants and string constants are \t and \n.
 - The compiler is two-pass.  In the first pass, the function is typechecked
   and a parse tree is constructed.  Constant folding and removal of dead
   code is done.  In the second pass, code for a virtual stackmachine is
   generated.  Jumps to jumps are optimized.  Optionally, the second pass
   may generate C code (not yet implemented).

Interpreter:

 - The interpreter has only 32 instructions.  Kfuns are not part of the
   interpreter proper.
 - Objects are pure programs.  They do not have inventories, environments,
   are not alive, do not have actions (all of this can be simulated).
 - Pathnames without a leading slash are considered to be relative to the
   directory of the current object (i.e. /foo for the object compiled from
   /foo/bar.c).
 - create() is called if a function in an object is called for the first
   time.  It is not called if an object is loaded because it is inherited.
   If it is desired that reset(0) is called instead, add the following to
   the auto object:

	void reset(int arg) { }

	nomask void create()
	{
	    reset(0);
	}

 - reset() is never called by the driver.  Both reset on reference and reset
   after a fixed period are easily simulated.
 - clean_up() is never called by the driver.
 - Text typed by a user is passed on by calling receive_message(text) in the
   interactive object.  The kfun send_message(text) can be used in interactive
   objects to send text back to the user.
 - There is no "master object" as in LPmud 3.1.2, but a "driver object"
   instead (there is nothing masterly about it in DGD).  It is used only to
   translate pathnames for #include and inherit, and to supply the object
   that is used for interactive connections.  It does not inherit the
   auto object, unless this is done explicitly.
 - There is no shadowing.
 - The default state of an object is swapped out.  Strings and arrays are
   only shared inside objects.  If an array is exported from one object to
   another, it will become a different array as soon as the object is swapped
   out (this is guaranteed never to happen during execution).
 - Self-referential datastructures will be deallocated when no more outside
   references exist, because they do not belong in any object.

Kfuns: DGD has about half of the kfuns of LPmud 3.1.2:
 - No kfuns such as environment(), this_player(), add_action().  Simulate them
   if you want them.
 - There is no exec(), heart_beat(), wizlist() (simulate them).
 - No parse_command().  It cannot be simulated, so people might want to port
   it to DGD, but it will never become part of "pure" DGD.
 - No alist kfuns.  I prefer mappings, even if alists are more powerful.
 - All file kfuns are unprotected.  To get either native or compat mode
   security, make the proper redefinitions in the auto object.
 - The built-in editor uses a temporary file and is very close to ex.
 - call_other() is typechecked if the called function is typechecked.  Calling
   a function that does not exist results in an error if the call has
   arguments (I still have to think about this).
 - There are no optional flag arguments to any kfun.

DGD 1.0.a1

 - ALLOCA() and AFREE() have replaced some instances of ALLOC() and FREE(),
   and be used to allocate memory with alloca(), if available on the host.
 - Mappings are now partially hashed.  If a mapping grows by assigning to
   an index/value that doesn't exist yet, the index/value pair is stored in
   a hash table.  Mappings are converted to sorted arrays of index/value
   pairs when swapped out.
 - Fixed some bugs in the compiler, interpreter and kfuns.
 - Changed the way line numbers are stored.  The interpreter no longer
   maintains the current line number at runtime.
 - Added int-only versions of some kfuns to speed up integer arithmetic in
   typechecked programs. Typechecked functions are now typechecked at runtime
   as well, to ensure that integer arguments are really integers.

DGD 1.0.a2

 - Better dead code removal.
 - Mixed return values are cast to int if needed.
 - Lvalues as function arguments are now handled properly.
 - Fixed a problem with (exp1, exp2) in aggregates and function arguments.
 - More untypechecked expressions are optimized.
 - String constants are marked as such.
 - Driver object has been enabled.
 - It is now illegal to call any function with too many arguments, even if the
   function has class vararg.
 - I removed the error on call_other() to a non-existing function.
 - When an object is cloned, or a function is called in it for the first time,
   create() in the object will be called.  
 - Added config file which is read on startup.
 - All ANSI escape sequences are now recognized in string constants and
   character constants.  Fixed a bug with #arg in macros.
 - Created proper main loop that reads input and calls receive_message() for
   the associated objects.
 - Created (single user) comm package.  DGD now works as a regular game driver.
 - Overview of functions called by the gamedriver (can be static):
   In the driver object:
    * void initialize()
	Initialize the mudlib.  Called once at program startup.
    * string path_ed_read(object, string)
	Path translation for editor read.
    * string path_ed_write(object, string)
	Path translation for editor write.
    * string path_object(object, string)
	Object path translation (for find_object, clone_object, etc).
    * string path_inherit(string, string)
	Inherit file name translation.
    * string path_include(string, string)
	Include file name translation.
    * object compile_object(string)
	Called if the given argument could not be compiled.  The driver
	object can return an object that will be renamed to the wanted
	object.  The returned object may be a clone, and will remain
	a clone (i.e. may not itself be cloned), even with the new name.
	Modelled after "virtual objects" in MudOS, the American LPmud brand.
    * object connect()
    * void log_error(string, string, string, int)
	Log a runtime error.
    * string compile_log(string)
	Return the name of the file to which compile time errormessages
	should be appended.
   In the user object:
    * void open()
	LPmud: login
    * void close()
	Called if the user connection to the mud is closed.
    * void receive_message(string)
	Called for user input.
   In an object that uses the editor() kfun:
    * void receive_message(string)
	Called for editor output.
 - Overview of the kfuns added:
    * varargs mixed call_other(mixed, string, ...);
    * object this_object();
    * varargs object previous_object(int);
	Return the previous object n+1 steps back in the call_other chain.
    * object clone_object(string);
    * void destruct_object(object);
	LPmud: destruct()
    * string object_name(object);
	LPmud: file_name()
    * object find_object(string);
    * string function_object(string, object);
	LPmud: function_exists()
    * object this_user();
	LPmud: this_player(1);
    * string query_ip_number(object);
    * object *users();
    * int strlen(string);
    * mixed *allocate(int);
    * int sizeof(mixed *);
    * mixed *map_indices(mapping);
	LPmud + mappings: m_indices()
    * mixed *map_values(mapping);
	LPmud + mappings: m_values()
    * int map_sizeof(mapping);
	LPmud + mappings: m_sizeof()
    * int intp(mixed);
    * int stringp(mixed);
    * int objectp(mixed);
    * int arrayp(mixed);
	LPmud: pointerp()
    * int mappingp(mixed);
    * void error(string);
	Cause an error.
    * void send_message(string);
	Send a message to the current object (should be interactive user),
	messages from the user will call receive_message() in the object.
    * int time();
    * varargs void call_out(string, int, ...);
    * int remove_call_out(string);
    * void shutdown();

    * void editor(string);
	Handle an editor command, such as "e file", "%s/foo/bar/g", "x".
	If no editor instance exists for the current object, it will be
	created; editor output will call receive_message() in the object.
    * string query_editor(object);
	Return the editor status of the object ("command", "input" or 0).
    * void save_object(string);
	LPmud: save_object() without .o tagged on.
    * int restore_object(string);
	LPmud: restore_object() without .o tagged on.
    * varargs string read_file(string, int, int);
	LPmud: read_bytes()
    * int rename_file(string, string);
	LPmud: rename() (limited, will not rename directories if the
	       host doesn't support this)
    * int remove_file(string);
	LPmud: rm()
    * varargs void write_file(string, string, int);
	LPmud: write_bytes(), will append if third argument is omitted.
    * int make_dir(string);
	LPmud: mkdir()
    * int remove_dir(string);
	LPmud: rmdir()
    * mixed **get_dir(string);
	Get file info using get_dir(file), directory info using
	get_dir(dir + "/" + pattern), the pattern can have ? * [a-z].
	The return value has this form:
	    ({ ({ names }), ({ mod times }), ({ sizes }) })
	This is almost compatible with MudOS, except that directories have
	size -2 (non-existing files and special files are not included).

    * varargs string crypt(string, string);
    * string ctime(int);
    * string *explode(string, string);
    * string implode(string*, string);
    * int random(int);
    * varargs int sscanf(string, string, ...);
	As in LPmud, but also handles %*s (skip assignment), %s%d and %%.

DGD 1.0.a3

 - Replaced objkey with separate fields in both objects and values.  Structure
   alignment on sun4 systems caused the size of a value to be 12 bytes, where
   it should have been 8.  It should now be 8 bytes on any host (as long as
   uindex is an unsigned short, and pointers use 4 bytes).
 - Redeclaring an inherited function with different parameters is now allowed
   (runtime typechecking will handle calls from inherited objects to the new
   function), but the return type still has to match.
 - Fixed a bug with the return type of an implicit prototype, which should
   read as mixed, when used.
 - Some checks to see if the result of path_file() was NULL were missing.
 - Removed time_interval from the configuration parameters.  If I'm going to
   support call_out intervals of less then a second, I'll do it in a different
   way.
 - The simulated rename() erroneously removed the destination if it existed.
 - Some checks for destructed this_object() in kfuns removed.  Either the
   error is caused from path_object(), or there was not real reason to block
   the kfun (file I/O).  Doing a call_other() from a destructed object is still
   illegal.
 - Special files are no longer excluded from a get_dir() listing.
 - Fixed some bugs in the compiler, where functions from different inherited
   objects were confused.
 - The type of the objcnt field in the value struct has been changed into
   Int, to save space on hosts that have 64-bit longs.
 - Replaced all variables called "index" by "idx".  index() is a function like
   strchr() on some systems.  Sigh.
 - Fixed a bad bug in integer comparisions.
 - The call_outs configuration parameter now specifies the maximum number of
   call_outs in all objects together, rather than per object.
 - The maximum execution cost is now set to the appropriate value at runtime
   (25% for call_outs), rather than once at initialisation.
 - call_out() and remove_call_out() now work.  The gamedriver is fully
   functional for a single user.
 - DGD now automatically generates a file called "limits.h" in the first
   include directory, which describes the sizes of datatypes and resources.
 - Fixed a problem with dumping function call traces of destructed objects.
 - Fixed several bugs in get_dir() and path_resolve().
 - Fixed a bug which occurred if a variable was defined with a name that had
   been used in an inherited object.
 - Destructing a destructed object gives an error, rather than a fatal error.
 - call_other() from a destructed object no longer results in an error, but
   is simply ignored, like in LPmud.
